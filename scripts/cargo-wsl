#!.venv/bin/python3

import argparse
import os
import subprocess
import sys
import xxhash
import tomllib
import common

# SETUP #######################################################################

temp = None
try:
    temp = (
        subprocess.check_output(
            "wslpath -au $(pwsh.exe -c 'echo $env:TEMP')", shell=True
        )
        .decode("ascii")
        .replace("\r\n", "")
    )
except:
    if not os.environ.get("HOSTPATH"):
        print("WARN: wsl not detected and HOSTPATH not set.")

env_vars = {
    # "WINDBG_EXE": {
    #     "description": "The windbg executable.",
    #     "default": "windbg.exe",
    # },
    # "RENDERDOC_EXE": {
    #     "description": "The qrenderdoc executable.",
    #     "default": "qrenderdoc.exe",
    # },
    "CARGO_CMD": {
        "description": "The cargo command to execute.",
        "default": "build",
    },
    "HOSTPATH": {
        "description": 'Directory for the final executable in "wslpath -au" style.',
        "default": temp,
    },
    "CARGO_BUILD_TARGET": {
        "description": "Build target for Cargo.",
        "default": "debug",
    },
    "SCP_FLAGS": {
        "description": "If SSH is detected, these flags will be added to the SCP command when syncing build files.",
        "default": None,
    },
}

# PARSE #######################################################################

epilog = "Accepts the following environment variables:\n"
for name, values in env_vars.items():
    epilog += f"{name}:\t{values.get('description')}\n\t\tDefaults to {values.get('default')}\n"

env = os.environ
parser = argparse.ArgumentParser(
    prog="cargo wsl",
    description="Builds the project assuming you're on WSL.",
    epilog=epilog,
    formatter_class=argparse.RawTextHelpFormatter,
)
parser.add_argument(
    "-b", "--no-build", action="store_true", help="Do not build the project."
)
parser.add_argument(
    "-s", "--no-sync", action="store_true", help="Do not sync the project."
)
parser.add_argument(
    "-H", "--no-hash", action="store_true", help="Do not check for changes."
)
parser.add_argument(
    "-r", "--no-run", action="store_true", help="Do not run the project."
)
parser.add_argument(
    "-t",
    "--trace",
    action="store_true",
    help="Runs with -F bevy/trace_tracy. On Windows this requires running the built application as an administrator.",
)
parser.add_argument("wsl", help="(dummy argument)")
# parser.add_argument(
#     "-W",
#     "--windbg",
#     action="store_true",
#     help="Run windbg after building.",
# )
# parser.add_argument(
#     "-R",
#     "--renderdoc",
#     action="store_true",
#     help="Run renderdoc after building.",
# )
parser.add_argument(
    "-F",
    "--feature",
    nargs=1,
    action="append",
    dest="features",
    help="Feature flags passed to cargo.",
    default=["debug", "inspector"],
)
parser.add_argument(
    "-v", "--verbose", action="count", help="Run verbosely.", default=0
)

args = common.parse_with_forward(parser, "cargo")
if args.trace:
    args.forward.concat(["-F", "bevy/trace_tracy"])


def print_and_run(cmd: str | list[str], **shargs):
    return common.print_and_run(cmd, args.verbose, **shargs)


for key in env_vars:
    env_vars[key] = os.environ.get(key) or env_vars[key].get("default")

pkg_name = "bevy_game"
with open("Cargo.toml", "rb") as f:
    toml = tomllib.load(f)
    pkg_name = toml.get("package").get("name")

profile = (
    "release"
    if "-r" in args.forward or "--release" in args.forward
    else "debug"
)
target_dir = os.path.abspath(
    os.path.join("target", env_vars["CARGO_BUILD_TARGET"], profile)
)


if args.verbose > 2:
    print(f"ARGS:\n{args}")
    print(f"ENV_VARS:\n{env_vars}")

ssh_connection = os.environ.get("SSH_CONNECTION")
if ssh_connection:
    print("SSH detected.")

# BUILD #######################################################################

if not args.no_build:
    print_and_run(
        [
            "cargo",
            env_vars["CARGO_CMD"],
            *args.forward,
        ]
    ).check_returncode()

    bin_path = os.path.join(env_vars["HOSTPATH"], pkg_name, pkg_name + ".exe")
    bin_path = (
        subprocess.check_output(f"wslpath -aw {bin_path}", shell=True)
        .decode()
        .replace("\n", "")
    )

    winpath = "$env:PATH"
    if "dev" in args.forward:
        try:
            rustlibs = (
                subprocess.check_output(
                    [
                        "rustc",
                        f"--target={env_vars['CARGO_BUILD_TARGET']}",
                        "--print",
                        "target-libdir",
                    ]
                )
                .decode()
                .strip()
            )
            rustlibs = (
                subprocess.check_output(["wslpath", "-aw", rustlibs])
                .decode()
                .strip()
            )
            deps = os.path.abspath(os.path.join(target_dir, "deps"))
            deps = (
                subprocess.check_output(["wslpath", "-aw", deps])
                .decode()
                .strip()
            )
            winpath = f"$env:PATH;{rustlibs};{deps};"

        except:
            print("WARN: Could not generate path to dynamic libraries!")

    runas = "-Verb RunAs" if args.trace else ""
    start = """\
    Start-Process  -Wait -Environment @{{
    RUST_LOG="{RUST_LOG}"
    DEBUG_LEVEL="{DEBUG_LEVEL}"
    PATH="{winpath}"
    }} -FilePath "{bin_path}" {runas}\
    2>&1 | Tee-Object -FilePath run.log\
    """.format(
        RUST_LOG=os.environ.get("RUST_LOG"),
        DEBUG_LEVEL=os.environ.get("DEBUG_LEVEL"),
        bin_path=bin_path,
        runas=runas,
        winpath=winpath,
    )
    if args.verbose > 1:
        print(f"start.ps1:\n{start}")
    start_path = os.path.join(target_dir, "start.ps1")
    with open(start_path, "w") as f:
        f.write(start)
else:
    print("Not building.")


# HASH #########################################################################
def do_hash():
    # generate checksum
    mismatched = ()
    hashfile = ""
    for file in build_files:
        with open(file, "rb") as f:
            hash = xxhash.xxh64_hexdigest(f.read())
            hashfile += f"{file} {hash}\n"

    for root, subdirs, files in os.walk("assets"):
        for file in files:
            path = os.path.join(root, file)
            with open(path, "rb") as f:
                hash = xxhash.xxh64_hexdigest(f.read())
                hashfile += f"{path} {hash}\n"

    # check the checksum
    hashfile_path = os.path.join(target_dir, ".hash")
    if os.path.exists(hashfile_path):
        with open(hashfile_path) as f:
            zipped = zip(hashfile.splitlines(), f.readlines())
            if args.verbose > 1:
                print(
                    "Comparing hashes:\n",
                    "\n".join(
                        list(
                            map(
                                lambda t: f"{t[0].split()[0]} {t[0].split()[1]} {t[1].split()[1]}",
                                zipped,
                            )
                        )
                    ),
                )
            filtered = filter(lambda tuple: tuple[0] != tuple[1], zipped)
            mismatched = list(map(lambda tuple: tuple[0].split()[0], filtered))
    else:
        mismatched = list(map(lambda l: l.split()[0], hashfile.splitlines()))

    # overwrite it
    with open(hashfile_path, "w") as f:
        f.write(hashfile)

    return mismatched


# SYNC #########################################################################
if not args.no_sync:
    exec_path = os.path.join(target_dir, pkg_name + ".exe")
    build_files = [start_path, exec_path]
    if "dev" in args.features:
        build_files.append(os.path.join(target_dir, "bevy_dylib.dll"))

    if args.no_hash:
        print("Not hashing.")
        mismatched = build_files
        for root, subdirs, files in os.walk("assets"):
            for file in files:
                path = os.path.join(root, file)
                mismatched.append(path)
    else:
        mismatched = do_hash()
    if args.verbose > 1:
        print("Mismatched files:", mismatched)

    # sync

    for local_file in mismatched:
        remote_file = local_file.replace(target_dir + "/", "")
        destination = os.path.join(env_vars["HOSTPATH"], pkg_name, remote_file)
        if ssh_connection:
            user = os.environ.get("USER")
            ssh_connection = ssh_connection.split()
            ip = ssh_connection[0]
            port = ssh_connection[1]
            destination = f"scp://{user}@{ip}:{port}/{destination}"
            print_and_run(
                ["scp", env_vars["SCP_FLAGS"] or "", local_file, destination]
            )
        else:
            print_and_run(["mkdir", "-p", os.path.dirname(destination)])
            print_and_run(["cp", local_file, destination])
else:
    print("Not syncing.")

# RUN #########################################################################
if not args.no_run and not ssh_connection:
    start_path = os.path.join(env_vars["HOSTPATH"], pkg_name, "start.ps1")
    start_path = (
        subprocess.check_output(f"wslpath -aw {start_path}", shell=True)
        .decode()
        .replace("\n", "")
    )
    tty = subprocess.check_output("wslpath -aw $(tty)", shell=True).decode()
    subprocess.call(["pwsh.exe", start_path])
else:
    print("Not running.")
